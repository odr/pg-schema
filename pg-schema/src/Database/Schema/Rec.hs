{-# LANGUAGE NoOverloadedStrings #-}
{-# LANGUAGE UndecidableInstances #-}
{-# LANGUAGE UndecidableSuperClasses #-}
module Database.Schema.Rec where

import Data.Kind
import Data.Singletons.TH
import Data.Text (Text)
import Database.PostgreSQL.Simple.Types as PG
import Database.Schema.Def
import PgSchema.Util
import Prelude.Singletons as SP
import Text.Show.Singletons


singletons [d|
  data FieldInfo' s = FieldInfo
    { fieldName :: s
    , fieldDbName :: s }
    deriving Show

  data QueryRecord' s = QueryRecord
    { tableName   :: NameNS' s
    , queryFields :: [QueryField' s] }
    deriving Show

  data QueryRef' s = QueryRef
    { fromName :: s
    , fromDef  :: FldDef' s
    , toName   :: s
    , toDef    :: FldDef' s }
    deriving Show

  data QueryField' s
    = FieldPlain s s (FldDef' s) -- name dbname flddef
    | FieldTo    s s (QueryRecord' s) [QueryRef' s] -- (children)
    | FieldFrom  s s (QueryRecord' s) [QueryRef' s] -- (parent)
    deriving Show
  |]

promote [d|
  fiWithType :: (s -> t) -> [FieldInfo' s] -> [(FieldInfo' s, t)]
  fiWithType f = map (\fi -> (fi, f $ fieldName fi))

  riFieldType
    :: Eq s
    => (s -> t) -> (s -> t) -> [FieldInfo' s] -> [FieldInfo' s] -> s -> t
  riFieldType f1 f2 rs1 rs2 n = find1 rs1
    where
      find1 []     = find2 rs2
      find1 (x:xs) = if fieldName x == n then f1 n else find1 xs
      find2 []     = error "riFieldType: No field found"
      find2 (x:xs) = if fieldName x == n then f2 n else find2 xs

  orField :: Eq s => [FieldInfo' s] -> [FieldInfo' s] -> s -> Bool
  orField rs1 rs2 n = find1 rs1
    where
      find1 []     = find2 rs2
      find1 (x:xs) = fieldName x == n || find1 xs
      find2 []     = False
      find2 (x:xs) = fieldName x == n || find2 xs

  noFieldTo :: [QueryField' s] -> Bool
  noFieldTo = all \case { FieldTo{} -> False; _ -> True }

  mkRefs :: [(s,s)] -> [FldDef' s] -> [FldDef' s] -> [QueryRef' s]
  mkRefs = zipWith3 (\(fromName,toName) fromDef toDef -> QueryRef {..})

  |]

type FieldInfoK = FieldInfo' Symbol
type QueryRecordK = QueryRecord' Symbol
type QueryRefK = QueryRef' Symbol
type QueryFieldK = QueryField' Symbol
type FieldInfo = FieldInfo' Text
type QueryRecord = QueryRecord' Text
type QueryRef = QueryRef' Text
type QueryField = QueryField' Text

-- | instances will be generated by TH
class CFieldType (r :: Type) (n :: Symbol) where
  type TFieldType r n :: Type

genDefunSymbols [''TFieldType]

instance OrField (TRecordInfo r1) (TRecordInfo r2) n ~ 'True
  => CFieldType (r1 PG.:. r2) n where
  type TFieldType (r1 PG.:. r2) n = RiFieldType
    (TFieldTypeSym1 r1) (TFieldTypeSym1 r2) (TRecordInfo r1) (TRecordInfo r2) n

-- | instances will be generated by TH
class ToStar (TRecordInfo r) => CRecordInfo r where
  type TRecordInfo r :: [FieldInfoK]

instance (CRecordInfo r1, CRecordInfo r2, ToStar (TRecordInfo (r1 PG.:. r2)))
  => CRecordInfo (r1 PG.:. r2) where
  type TRecordInfo (r1 PG.:. r2) = TRecordInfo r1 ++ TRecordInfo r2

instance
  ( CQueryRecord db sch t r1, CQueryRecord db sch t r2
  , CQueryFields db sch t (FiTypeInfo (r1 :. r2))
  )
  => CQueryRecord db sch t (r1 :. r2)

recordInfo :: forall r. CRecordInfo r => [FieldInfo]
recordInfo = demote @(TRecordInfo r)

type FiTypeInfo r = FiWithType (TFieldTypeSym1 r) (TRecordInfo r)

-- record over table
class
  ( CQueryFields db sch tab (FiTypeInfo r)
  , ToStar (TQueryRecord db sch tab r) )
  => CQueryRecord (db::Type) (sch::Type) (tab::NameNSK) (r::Type) where
  type TQueryRecord db sch tab r :: QueryRecordK
  type TQueryRecord db sch tab r = 'QueryRecord tab
    (TQueryFields db sch tab (FiWithType (TFieldTypeSym1 r) (TRecordInfo r)))
  -- getQueryRecord :: QueryRecord
  -- getQueryRecord = QueryRecord {..}
  --   where
  --     tableName = demote @tab
  --     queryFields = getQueryFields
  --       @db @sch @tab @(FiWithType (TFieldTypeSym1 r) (TRecordInfo r))

getQueryRecord
  :: forall db sch tab r. CQueryRecord db sch tab r => QueryRecord
getQueryRecord  = demote @(TQueryRecord db sch tab r)

class CTypDef sch tn => CanConvert db sch (tn::NameNSK) (nullable::Bool) t

-- classify fields of record over table: Plain, RefTo, RefFrom
class
  (CSchema sch, CTabDef sch t, ToStar (TQueryFields db sch t fis))
  => CQueryFields db sch (t::NameNSK) (fis :: [(FieldInfoK,Type)]) where
  type TQueryFields db sch t fis :: [QueryFieldK]

getQueryFields :: forall db sch t fis. CQueryFields db sch t fis => [QueryField]
getQueryFields = demote @(TQueryFields db sch t fis)


class CQueryFieldT (ft::FldKindK) db sch (t::NameNSK) (fi::(FieldInfoK,Type))
  where
    type TQueryFieldT ft db sch t fi :: QueryFieldK
    -- getQueryFieldT :: QueryField
--
class CQueryFieldTB (nullable :: Bool) rd db sch t (fi::(FieldInfoK,Type))
  where
    type TQueryFieldTB nullable rd db sch t fi :: QueryFieldK
    -- getQueryFieldTB :: QueryField

instance CQueryFieldTB (IsMaybe r) rd db sch t '(fi, r)
  => CQueryFieldT ('FldFrom rd) db sch t '(fi, r)
  where
    type TQueryFieldT ('FldFrom rd) db sch t '(fi, r) =
      TQueryFieldTB (IsMaybe r) rd db sch t '(fi, r)
  -- getQueryFieldT = getQueryFieldTB @(IsMaybe r) @rd @db @sch @t @'(fi, r)

instance (CSchema sch, CTabDef sch t) => CQueryFields db sch t '[] where
  type TQueryFields db sch t '[] = '[]

type family IsMaybe (x :: Type) :: Bool where
  IsMaybe (Maybe a) = 'True
  IsMaybe x = 'False

instance
  ( CQueryFieldT (TFieldKind sch t (FieldDbName (Fst x))) db sch t x
  , CQueryFields db sch t xs, CSchema sch, CTabDef sch t
  , ToStar (TQueryFields db sch t (x ': xs)))
  => CQueryFields db sch t (x ': xs) where
  type TQueryFields db sch t (x ': xs) =
    TQueryFieldT (TFieldKind sch t (FieldDbName (Fst x))) db sch t x
    ': TQueryFields db sch t xs
  -- getQueryFields
  --   = getQueryFieldT @(TFieldKind sch t (FieldDbName (Fst x))) @db @sch @t @x
  --   : getQueryFields @db @sch @t @xs

instance
  ( CFldDef sch t dbname, fdef ~ TFldDef sch t dbname, ToStar n
  , CanConvert db sch (FdType fdef) (FdNullable fdef) ftype )
  => CQueryFieldT 'FldPlain db sch t '( 'FieldInfo n dbname, ftype)
  where
    type TQueryFieldT 'FldPlain db sch t '( 'FieldInfo n dbname, ftype) =
      'FieldPlain n dbname (TFldDef sch t dbname)
  -- getQueryFieldT =
  --   FieldPlain (demote @n) (demote @dbname) (fldDef @sch @t @dbname)

instance
  ( tabTo ~ RdTo rd, CQueryRecord db sch tabTo recTo
  , cols ~ RdCols rd, uncols ~ Unzip cols
  , fds ~ SP.Map (TFldDefSym2 sch t) (Fst uncols)
  , HasNullable fds ~ 'False
  , fdsTo ~ SP.Map (TFldDefSym2 sch tabTo) (Snd uncols)
  , ToStar cols, ToStar fds, ToStar fdsTo, ToStar n, ToStar dbname )
  => CQueryFieldTB 'False rd db sch t '( 'FieldInfo n dbname, recTo)
  where
    -- type TQueryFieldTB 'False rd db sch t '( 'FieldInfo n dbname, recTo) =
    --   'FieldFrom n dbname (TQueryRecord db sch tabTo recTo) (MkRefs cols fds fdsTo)
    type TQueryFieldTB 'False rd db sch t '( 'FieldInfo n dbname, recTo) =
      'FieldFrom n dbname
        (TQueryRecord db sch (RdTo rd) recTo)
        (MkRefs (RdCols rd)
          (SP.Map (TFldDefSym2 sch t) (Fst (Unzip (RdCols rd))))
          (SP.Map (TFldDefSym2 sch (RdTo rd)) (Snd (Unzip (RdCols rd)))))

  -- getQueryFieldTB = FieldFrom (demote @n) (demote @dbname)
  --   (getQueryRecord @db @sch @tabTo @recTo) refs
  --   where
  --     refs = zipWith3 (\(fromName,toName) fromDef toDef -> QueryRef {..})
  --       (demote @cols) (demote @fds) (demote @fdsTo)
--
instance
  ( tabTo ~ RdTo rd, CQueryRecord db sch tabTo recTo
  , cols ~ RdCols rd, uncols ~ Unzip cols
  , fds ~ SP.Map (TFldDefSym2 sch t) (Fst uncols)
  , fdsTo ~ SP.Map (TFldDefSym2 sch tabTo) (Snd uncols)
  , ToStar cols, ToStar fds, ToStar fdsTo, ToStar n, ToStar dbname )
  => CQueryFieldTB 'True rd db sch t '( 'FieldInfo n dbname, Maybe recTo)
  where
    -- type TQueryFieldTB 'True rd db sch t '( 'FieldInfo n dbname, Maybe recTo) =
    --   FieldFrom n dbname (TQueryRecord db sch tabTo recTo) (MkRefs cols fds fdsTo)
    type TQueryFieldTB 'True rd db sch t '( 'FieldInfo n dbname, Maybe recTo) =
      'FieldFrom n dbname (TQueryRecord db sch (RdTo rd) recTo)
        (MkRefs (RdCols rd)
          (SP.Map (TFldDefSym2 sch t) (Fst (Unzip (RdCols rd))))
          (SP.Map (TFldDefSym2 sch (RdTo rd)) (Snd (Unzip (RdCols rd)))))

    -- getQueryFieldTB = FieldFrom (demote @n) (demote @dbname)
    --   (getQueryRecord @db @sch @tabTo @recTo) refs
    --   where
    --     refs = zipWith3 (\(fromName,toName) fromDef toDef -> QueryRef {..})
    --       (demote @cols) (demote @fds) (demote @fdsTo)

instance
  ( tabFrom ~ RdFrom rd, CQueryRecord db sch tabFrom recFrom
  , cols ~ RdCols rd, uncols ~ Unzip cols
  , fds ~ SP.Map (TFldDefSym2 sch t) (Snd uncols)
  , fdsFrom ~ SP.Map (TFldDefSym2 sch tabFrom) (Fst uncols)
  , ToStar cols, ToStar fds, ToStar fdsFrom, ToStar n, ToStar dbname )
  => CQueryFieldT ('FldTo rd) db sch t '( 'FieldInfo n dbname, recFrom) where
  -- type TQueryFieldT = 'FieldTo n dbname (TQueryRecord db sch tabFrom recFrom)
  --   (MkRefs cols fdsFrom fds)
    type TQueryFieldT ('FldTo rd) db sch t '( 'FieldInfo n dbname, recFrom) =
      'FieldTo n dbname (TQueryRecord db sch (RdFrom rd) recFrom)
        (MkRefs (RdCols rd)
          (SP.Map (TFldDefSym2 sch (RdFrom rd)) (Fst (Unzip (RdCols rd))))
          (SP.Map (TFldDefSym2 sch t) (Snd (Unzip (RdCols rd)))))

  -- getQueryFieldT = FieldTo (demote @n) (demote @dbname)
  --   (getQueryRecord @db @sch @tabFrom @recFrom) refs
  --   where
  --     refs = zipWith3 (\(fromName,toName) fromDef toDef -> QueryRef {..})
  --       (demote @cols) (demote @fdsFrom) (demote @fds)

type AllMandatory sch t r =
  IsAllMandatory sch t (Map FieldDbNameSym0 (TRecordInfo r)) ~ 'True
