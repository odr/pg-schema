{-# LANGUAGE NoOverloadedStrings #-}
{-# LANGUAGE UndecidableInstances #-}
module Database.Schema.Rec where

import Data.Kind
import Data.Singletons.TH
import Data.Text (Text)
import Database.PostgreSQL.Simple.Types as PG
import Database.Schema.Def
import GHC.TypeLits qualified as TL
-- import GHC.TypeLits (ErrorMessage(..))
import GHC.TypeError
import PgSchema.Util
import Prelude.Singletons as SP
import Text.Show.Singletons


singletons [d|
  data FieldInfo' s = FieldInfo
    { fieldName :: s
    , fieldDbName :: s }
    deriving Show

  data QueryRecord' s = QueryRecord
    { qTableName   :: NameNS' s
    , qFields :: [QueryField' s] }
    deriving Show

  data Ref' s = Ref
    { fromName :: s -- db field name
    , fromDef  :: FldDef' s
    , toName   :: s
    , toDef    :: FldDef' s }
    deriving (Eq, Show)

  data QueryField' s
    = QFieldPlain (FieldPlain' s)
    | QFieldTo    (FieldRef' (QueryRecord' s) s) -- (children)
    | QFieldFrom  (FieldRef' (QueryRecord' s) s) -- (parent)
    | QFieldEmpty s
    deriving Show

  data DmlRecord' s = DmlRecord
    { iTableName   :: NameNS' s
    , iFields :: [DmlField' s] }
    deriving Show

  data FieldRef' r s = FieldRef
    { frName :: s
    , frDbName :: s
    , frRec :: r
    , frRefs :: [Ref' s] }
    deriving Show

  data FieldPlain' s = FieldPlain
    { fpName :: s
    , fpDbName :: s
    , fpFldDef :: FldDef' s }
    deriving Show

  data DmlField' s
    = DmlFieldPlain (FieldPlain' s)
    | DmlFieldTo (FieldRef' (DmlRecord' s) s) -- (children)
    deriving Show
  |]

promote [d|
  riFieldType
    :: Eq s
    => (s -> t) -> (s -> t) -> [FieldInfo' s] -> [FieldInfo' s] -> s -> t
  riFieldType f1 f2 rs1 rs2 n = find1 rs1
    where
      find1 []     = find2 rs2
      find1 (x:xs) = if fieldName x == n then f1 n else find1 xs
      find2 []     = error "riFieldType: No field found"
      find2 (x:xs) = if fieldName x == n then f2 n else find2 xs

  orField :: Eq s => [FieldInfo' s] -> [FieldInfo' s] -> s -> Bool
  orField rs1 rs2 n = find1 rs1
    where
      find1 []     = find2 rs2
      find1 (x:xs) = fieldName x == n || find1 xs
      find2 []     = False
      find2 (x:xs) = fieldName x == n || find2 xs

  mkRefs :: RelDef' s -> (s -> FldDef' s) -> (s -> FldDef' s) -> [Ref' s]
  mkRefs rd f1 f2 = mkRefs' cols (map f1 cols1) (map f2 cols2)
    where
      mkRefs' = zipWith3 (\(fromName,toName) fromDef toDef -> Ref {..})
      cols = rdCols rd
      (cols1, cols2) = unzip cols

  hasNullableRefTo :: RelDef' s -> (s -> FldDef' s) -> Bool
  hasNullableRefTo rd f = any (fdNullable . f) $ fst $ unzip $ rdCols rd

  justIPlain :: DmlField' s -> Maybe (FieldPlain' s)
  justIPlain (DmlFieldPlain ifp) = Just ifp
  justIPlain _ = Nothing

  justITo :: DmlField' s -> Maybe (FieldRef' (DmlRecord' s) s)
  justITo (DmlFieldTo ift) = Just ift
  justITo _ = Nothing

  subDmlRecord :: Eq s => QueryRecord' s -> DmlRecord' s -> Bool
  subDmlRecord (QueryRecord tn flds) ir2 =
    tn == iTableName ir2 && all check flds
    where
      check = \case
        QFieldPlain{} -> True
        QFieldEmpty{} -> True
        QFieldFrom{} -> False
        QFieldTo (FieldRef _ dbname1 qr1' _) ->
          case foldr sameFieldTo Nothing (iFields ir2) of
            Nothing -> False
            Just ir2' -> subDmlRecord qr1' ir2'
          where
            sameFieldTo DmlFieldPlain{} Nothing = Nothing
            sameFieldTo (DmlFieldTo (FieldRef _ dbname2 ir2' _)) Nothing =
              if dbname1 == dbname2 then Just ir2' else Nothing
            sameFieldTo _ justR = justR

  allDmlPlainB :: DmlRecord' s -> Bool
  allDmlPlainB  (DmlRecord _tn flds) = all isPlain flds
    where
      isPlain (DmlFieldPlain _) = True
      isPlain _ = False
  |]

type FieldInfoK = FieldInfo' Symbol
type RefK = Ref' Symbol
type QueryRecordK = QueryRecord' Symbol
type QueryFieldK = QueryField' Symbol
type DmlRecordK = DmlRecord' Symbol
type DmlFieldK = DmlField' Symbol
type DmlFieldToK = FieldRef' Symbol
type FieldPlaink = FieldPlain' Symbol
type FieldInfo = FieldInfo' Text
type Ref = Ref' Text
type QueryRecord = QueryRecord' Text
type QueryField = QueryField' Text
type DmlRecord = DmlRecord' Text
type DmlField = DmlField' Text
type DmlFieldTo = FieldRef' Text
type FieldPlain = FieldPlain' Text


-- | instances will be generated by TH
class CFieldType (r :: Type) (n :: Symbol) where
  type TFieldType r n :: Type

genDefunSymbols [''TFieldType]

-- | instances will be generated by TH
class ToStar (TRecordInfo r) => CRecordInfo r where
  type TRecordInfo r :: [FieldInfoK]

recordInfo :: forall r. CRecordInfo r => [FieldInfo]
recordInfo = demote @(TRecordInfo r)

-- record over table
class
  ( CQueryFields db sch tab (TRecordInfo r) (TFieldTypeSym1 r)
  , ToStar (TQueryRecord db sch tab r) )
  => CQueryRecord (db::Type) (sch::Type) (tab::NameNSK) (r::Type) where
  type TQueryRecord db sch tab r :: QueryRecordK
  type TQueryRecord db sch tab r = 'QueryRecord tab
    (TQueryFields db sch tab (TRecordInfo r) (TFieldTypeSym1 r))

getQueryRecord
  :: forall db sch tab r -> CQueryRecord db sch tab r => QueryRecord
getQueryRecord db sch tab r = demote @(TQueryRecord db sch tab r)

class CTypDef sch tn => CanConvert db sch (tn::NameNSK) (nullable::Bool) t

-- classify fields of record over table: Plain, RefTo, RefFrom
class CQueryFields db sch (t::NameNSK) (fis :: [FieldInfoK]) (fun :: Symbol ~> Type) where
  type TQueryFields db sch t fis fun :: [QueryFieldK]

instance CQueryFields db sch t '[] fun where
  type TQueryFields db sch t '[] fun = '[]

instance
  ( CQueryField (TFieldKind sch t (FieldDbName x)) db sch t '(x, Apply fun (FieldName x))
  , CQueryFields db sch t xs fun)
  => CQueryFields db sch t (x ': xs) fun where
  type TQueryFields db sch t (x ': xs) fun  =
    TQueryField (TFieldKind sch t (FieldDbName x)) db sch t '(x, Apply fun (FieldName x))
    ': TQueryFields db sch t xs fun

class CQueryField (ft::FldKindK) db sch (t::NameNSK) (fi::(FieldInfoK,Type))
  where
    type TQueryField ft db sch t fi :: QueryFieldK

instance
  ( CanConvert db sch (FdType (TFldDef sch t dbname)) (FdNullable (TFldDef sch t dbname)) ftype )
  => CQueryField 'FldPlain db sch t '( 'FieldInfo n dbname, ftype)
  where
    type TQueryField 'FldPlain db sch t '( 'FieldInfo n dbname, ftype) =
      'QFieldPlain ('FieldPlain n dbname (TFldDef sch t dbname))

instance ( CQueryRecord db sch (RdFrom rd) recFrom )
  => CQueryField ('FldTo rd) db sch t '( 'FieldInfo n dbname, recFrom) where
  type TQueryField ('FldTo rd) db sch t '( 'FieldInfo n dbname, recFrom) =
    'QFieldTo (FieldRef n dbname (TQueryRecord db sch (RdFrom rd) recFrom)
      (MkRefs rd (TFldDefSym2 sch (RdFrom rd)) (TFldDefSym2 sch t)))

instance
  ( CQueryRecord db sch (RdTo rd) (Snd (UnMaybe recTo))
  , HasNullableRefTo rd (TFldDefSym2 sch t) ~ Fst (UnMaybe recTo) )
  => CQueryField ('FldFrom rd) db sch t '( 'FieldInfo n dbname, recTo) where
  type TQueryField ('FldFrom rd) db sch t '( 'FieldInfo n dbname, recTo) =
    'QFieldFrom (FieldRef n dbname
      (TQueryRecord db sch (RdTo rd) (Snd (UnMaybe recTo)))
      (MkRefs rd (TFldDefSym2 sch t) (TFldDefSym2 sch (RdTo rd))))
--
type family UnMaybe (x :: Type) :: (Bool, Type) where
  UnMaybe (Maybe a) = '( 'True, a)
  UnMaybe a = '( 'False, a)

type RestMand sch t r rFlds =
  RestMandatory sch t (Map FieldDbNameSym0 (TRecordInfo r) ++ rFlds)

type family AllDmlPlain db sch tab r where
  AllDmlPlain db sch t r = Assert
    (AllDmlPlainB (TDmlRecord db sch t r))
    (TL.TypeError
      ((TL.Text "Not all fields in record are 'plain' fields " :<>: TL.ShowType t
        :<>: TL.Text " in type " :<>: TL.ShowType r)))

--------- DmlRecord --------

class ( ToStar (TDmlRecord db sch tab r)
  , CDmlFields db sch tab (TRecordInfo r) (TFieldTypeSym1 r))
  => CDmlRecord (db::Type) (sch::Type) (tab::NameNSK) (r::Type) where
  type TDmlRecord db sch tab r :: DmlRecordK
  type TDmlRecord db sch tab r = 'DmlRecord tab
    (TDmlFields db sch tab (TRecordInfo r) (TFieldTypeSym1 r))

getDmlRecord
  :: forall db sch tab r -> CDmlRecord db sch tab r => DmlRecord
getDmlRecord db sch tab r = demote @(TDmlRecord db sch tab r)

class CDmlFields db sch (t::NameNSK) (fis :: [FieldInfoK]) (fun :: Symbol ~> Type) where
  type TDmlFields db sch t fis fun :: [DmlFieldK]

instance CDmlFields db sch t '[] fun where
  type TDmlFields db sch t '[] fun = '[]

instance
  ( CDmlField (TFieldKind sch t (FieldDbName x)) db sch t '(x, Apply fun (FieldName x))
  , CDmlFields db sch t xs fun)
  => CDmlFields db sch t (x ': xs) fun where
  type TDmlFields db sch t (x ': xs) fun =
    TDmlField (TFieldKind sch t (FieldDbName x)) db sch t '(x, Apply fun (FieldName x))
    ': TDmlFields db sch t xs fun

class CDmlField (ft::FldKindK) db sch (t::NameNSK) (fi::(FieldInfoK,Type))
  where
    type TDmlField ft db sch t fi :: DmlFieldK

instance
  ( CFldDef sch t dbname, fdef ~ TFldDef sch t dbname
  , CanConvert db sch (FdType fdef) (FdNullable fdef) ftype )
  => CDmlField 'FldPlain db sch t '( 'FieldInfo n dbname, ftype)
  where
    type TDmlField 'FldPlain db sch t '( 'FieldInfo n dbname, ftype) =
      DmlFieldPlain ('FieldPlain n dbname (TFldDef sch t dbname))

class ( CDmlFields db sch (RdFrom rd) (TRecordInfo r) (TFieldTypeSym1 r) )
  => CDmlRecordChild (db::Type) (sch::Type) (rd::RelDefK) (r::Type)
  where
    type TDmlRecordChild db sch rd r :: DmlRecordK
    type TDmlRecordChild db sch rd r = 'DmlRecord (RdFrom rd)
      (TDmlFields db sch (RdFrom rd) (TRecordInfo r) (TFieldTypeSym1 r))

instance (CDmlRecordChild db sch rd recFrom)
  => CDmlField ('FldTo rd) db sch t '( 'FieldInfo n dbname, recFrom)
  where
    type TDmlField ('FldTo rd) db sch t '( 'FieldInfo n dbname, recFrom) =
      'DmlFieldTo
        ('FieldRef n dbname (TDmlRecordChild db sch rd recFrom)
        (MkRefs rd (TFldDefSym2 sch (RdFrom rd)) (TFldDefSym2 sch t)))

type SubDml db sch t r r' = Assert
  (SubDmlRecord (TQueryRecord db sch t r') (TDmlRecord db sch t r))
  (TL.TypeError
    (TL.Text "Result record doesn't correspond to input record"
    :$$: TL.Text "Input: " :<>: TL.ShowType r
    :$$: TL.Text "Result: " :<>: TL.ShowType r'))

type UpdateReturning db sch t r r' =
  (CDmlRecord db sch t r, CQueryRecord db sch t r', SubDml db sch t r r')

------------------------- PG.:. ----------

instance OrField (TRecordInfo r1) (TRecordInfo r2) n ~ 'True
  => CFieldType (r1 PG.:. r2) n where
  type TFieldType (r1 PG.:. r2) n = RiFieldType
    (TFieldTypeSym1 r1) (TFieldTypeSym1 r2) (TRecordInfo r1) (TRecordInfo r2) n

instance (CRecordInfo r1, CRecordInfo r2, ToStar (TRecordInfo (r1 PG.:. r2)))
  => CRecordInfo (r1 PG.:. r2) where
  type TRecordInfo (r1 PG.:. r2) = TRecordInfo r1 ++ TRecordInfo r2

instance
  ( CSchema sch, CQueryFields db sch t (TRecordInfo (r1 :. r2)) (TFieldTypeSym1 (r1 :. r2))
  , ToStar (TQueryRecord db sch t (r1 :. r2)))
  => CQueryRecord db sch t (r1 :. r2)

instance
  ( CSchema sch, CDmlFields db sch t (TRecordInfo (r1 :. r2)) (TFieldTypeSym1 (r1 :. r2))
  , ToStar (TDmlRecord db sch t (r1 :. r2)))
  => CDmlRecord db sch t (r1 :. r2)
