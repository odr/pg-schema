{-# LANGUAGE NoDuplicateRecordFields #-}
{-# LANGUAGE NoOverloadedStrings #-}
{-# LANGUAGE UndecidableInstances #-}
{-# LANGUAGE UndecidableSuperClasses #-}
{-# LANGUAGE ParallelListComp #-}
module Database.Schema.Def where

import Data.Kind
import Data.List as L
import Data.List.Singletons as SP
import Data.Map as M
import Data.Ord.Singletons
import Data.Singletons.TH
import Data.Text as T
import Language.Haskell.TH.Syntax
import PgSchema.Util
import Prelude.Singletons as SP
import Text.Show.Singletons
import Util.TH.LiftType


singletons [d|

  data NameNS' s = NameNS
    { nnsNamespace  :: s
    , nnsName       :: s }
    deriving (Show, Eq, Ord)

  data TypDef' s = TypDef
    { typCategory :: s
    , typElem     :: Maybe (NameNS' s)
    , typEnum     :: [s] }
    deriving (Show, Eq)

  data FldDef' s = FldDef
    { fdType        :: NameNS' s
    , fdNullable    :: Bool
    , fdHasDefault  :: Bool }
    deriving (Show, Eq)

  data TabDef' s = TabDef
    { tdFlds       :: [s]
    , tdKey        :: [s]
    , tdUniq       :: [[s]] }
    deriving (Show, Eq)

  data RelDef' s = RelDef
    { rdFrom    :: NameNS' s
    , rdTo      :: NameNS' s
    , rdCols    :: [(s,s)] }
    deriving (Show, Eq)
  |]

promote [d|
  getRelTab
    :: Eq s
    => [(NameNS' s, RelDef' s)] -> [(NameNS' s, RelDef' s)] -> s -> NameNS' s
  getRelTab froms tos s = find1 froms
    where
      find1 []         = find2 tos
      find1 ((a,b):xs) = if nnsName a == s then rdTo b else find1 xs
      find2 []         = error "No relation by name"
      find2 ((a,b):xs) = if nnsName a == s then rdFrom b else find2 xs

  restMandatory' :: Eq s => (s -> FldDef' s) -> TabDef' s -> [s] -> [s]
  restMandatory' f td recFlds =
    L.filter (isMandatory . f) (tdFlds td) L.\\ recFlds
    where
      isMandatory fd = not (fdNullable fd || fdHasDefault fd)
  |]

type NameNSK = NameNS' Symbol
type TypDefK = TypDef' Symbol
type FldDefK = FldDef' Symbol
type TabDefK = TabDef' Symbol
type RelDefK = RelDef' Symbol

type NameNS = NameNS' Text
type TypDef = TypDef' Text
type FldDef = FldDef' Text
type TabDef = TabDef' Text
type RelDef = RelDef' Text

infixr 9 ->>
(->>) :: Text -> Text -> NameNS
(->>) = NameNS

type ns ->> name = 'NameNS ns name

-- CTypDef
-- | instances will be generated by TH or codegen
class
  (ToStar name, ToStar (TTypDef sch name)) => CTypDef sch (name :: NameNSK) where

  type TTypDef sch name :: TypDefK

genDefunSymbols [''TTypDef]

-- CFldDef
-- | instances will be generated by TH or codegen
class
  ( ToStar fname, ToStar tname, ToStar (TFldDef sch tname fname)
  , CTypDef sch (FdType (TFldDef sch tname fname)) )
  => CFldDef sch (tname::NameNSK) (fname::Symbol) where
  type TFldDef sch tname fname :: FldDefK

genDefunSymbols [''TFldDef]

-- CTabDef
-- | instances will be generated by TH or codegen
class
  ( ToStar name, ToStar (TTabDef sch name)
  , ToStar (SP.Map (TFldDefSym2 sch name) (TdFlds (TTabDef sch name)))
  , ToStar (SP.Map (TFldDefSym2 sch name) (TdKey (TTabDef sch name)))
  , ToStar
    (SP.Map (SP.MapSym1 (TFldDefSym2 sch name)) (TdUniq (TTabDef sch name)))
  , ToStar
    ( ConcatMap (MapSym1 (TFldDefSym2 sch name)) (TdUniq (TTabDef sch name)) )
  ) => CTabDef sch (name::NameNSK) where

  type TTabDef sch name :: TabDefK

-- CRelDef
-- | instances will be generated by TH or codegen
class
  ( ToStar name, ToStar (TRelDef sch name)
  , CTabDef sch (RdFrom (TRelDef sch name))
  , CTabDef sch (RdTo (TRelDef sch name))
  , ToStar (RdCols (TRelDef sch name))
  , ToStar (SP.Map (TFldDefSym2 sch (RdFrom (TRelDef sch name)))
    (SP.Map FstSym0 (RdCols (TRelDef sch name))))
  , ToStar (SP.Map (TFldDefSym2 sch (RdTo (TRelDef sch name)))
    (SP.Map SndSym0 (RdCols (TRelDef sch name))))
  -- , ToStar (TTypeDefs sch)
  )
  => CRelDef sch (name::NameNSK) where

  type TRelDef sch name :: RelDefK

genDefunSymbols [''TTabDef, ''TRelDef]
-- we can also defun CTabDef and CRelDef but this is not needed

class CTabRels sch (tab :: NameNSK) where
  type TFrom sch tab :: [NameNSK]
  type TTo sch tab :: [NameNSK]

genDefunSymbols [''TFrom, ''TTo]

type RestMandatory sch t rs =
  RestMandatory' (TFldDefSym2 sch t) (TTabDef sch t) rs

promote [d|
  zip2With :: (a -> b -> c) -> [a] -> [[b]] -> [[c]]
  zip2With f = L.zipWith (L.map . f)

  map2 :: (a -> b) -> [a] -> [(a,b)]
  map2 f = L.map (\a -> (a, f a))

  map3 :: (b -> c) -> (a -> [b]) -> [a] -> [[(b,c)]]
  map3 f g = L.map (map2 f . g)
  |]


type TTabRelFrom sch tab = Map2 (TRelDefSym1 sch) (TFrom sch tab)
type TTabRelTo sch tab = Map2 (TRelDefSym1 sch) (TTo sch tab)

-- | instances will be generated by TH
class
  ( ToStar (TTabs sch)
  , ToStar (TTabRelFroms sch)
  , ToStar (TTabRelTos sch)
  , ToStar (TTabFldDefs sch)
  , ToStar (TTabFlds sch)
  , ToStar (TTabDefs sch)
  , ToStar (TTypes sch)
  , ToStar (SP.Map (TTypDefSym1 sch) (TTypes sch))
  )
  => CSchema sch where

  type TTabs sch    :: [NameNSK]
  type TTypes sch   :: [NameNSK]

type TTabDefs sch = SP.Map (TTabDefSym1 sch) (TTabs sch)
type TTabFlds sch = SP.Map TdFldsSym0 (TTabDefs sch)
type TTabFldDefs sch = Zip2With (TFldDefSym1 sch) (TTabs sch) (TTabFlds sch)
type TTabRelFroms sch = Map3 (TRelDefSym1 sch) (TFromSym1 sch) (TTabs sch)
type TTabRelTos sch = Map3 (TRelDefSym1 sch) (TToSym1 sch) (TTabs sch)

type TTypeDefs sch = Map2 (TTypDefSym1 sch) (TTypes sch)

--
data TabInfo = TabInfo
  { tiDef  :: TabDef
  , tiFlds :: M.Map Text FldDef
  , tiFrom :: M.Map NameNS RelDef
  , tiTo   :: M.Map NameNS RelDef }
  deriving (Show, Eq)

tabInfoMap :: forall sch. CSchema sch => M.Map NameNS TabInfo
tabInfoMap = M.fromList
  [ (tabName, tabInfo)
  | tabName <- demote @(TTabs sch)
  | tabInfo <-
    [ TabInfo{..}
    | tiDef <- demote @(TTabDefs sch)
    | tiFlds <-
      [ M.fromList $ L.zip fs ds
      | fs <- demote @(TTabFlds sch)
      | ds <- demote @(TTabFldDefs sch) ]
    | tiFrom <- M.fromList <$> demote @(TTabRelFroms sch)
    | tiTo <- M.fromList <$> demote @(TTabRelTos sch)
    ]
  ]

typDefMap :: forall sch. CSchema sch => M.Map NameNS TypDef
typDefMap = M.fromList $ L.zip
  (demote @(TTypes sch)) (demote @(SP.Map (TTypDefSym1 sch) (TTypes sch)))

type TRelTab sch t name = GetRelTab
  (Map2 (TRelDefSym1 sch) (TFrom sch t)) (Map2 (TRelDefSym1 sch) (TTo sch t))
  name

type family TabOnPath sch (t :: NameNSK) (path :: [Symbol]) :: NameNSK where
  TabOnPath sch t '[] = t
  TabOnPath sch t (x ': xs) = TabOnPath sch (TRelTab sch t x) xs
--
type family TabPath sch (t :: NameNSK) (path :: [Symbol]) :: Constraint where
  TabPath sch t '[] = ()
  TabPath sch t (x ': xs) = TabPath sch (TRelTab sch t x) xs
--
instance LiftType NameNS where
  liftType NameNS{..} =
    [t| $(liftType nnsNamespace) ->> $(liftType nnsName) |]

instance Lift NameNS where
  liftTyped (NameNS ns n) = [|| NameNS $$(liftTyped ns) $$(liftTyped n) ||]

instance LiftType TypDef where
  liftType TypDef{..} = [t| 'TypDef
    $(liftType typCategory) $(liftType typElem) $(liftType typEnum) |]

instance LiftType FldDef where
  liftType FldDef{..} = [t| 'FldDef
    $(liftType fdType) $(liftType fdNullable) $(liftType fdHasDefault) |]

instance LiftType TabDef where
  liftType TabDef{..} =
    [t| 'TabDef $(liftType tdFlds) $(liftType tdKey) $(liftType tdUniq) |]

instance LiftType RelDef where
  liftType RelDef{..} =
    [t| 'RelDef $(liftType rdFrom) $(liftType rdTo) $(liftType rdCols) |]
--
